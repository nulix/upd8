use anyhow::{Result, Context, anyhow};
use log::{info, debug};
use std::path::Path;
use std::fs;
use curl::easy::List;
use serde_json::json;
use secrecy::ExposeSecret;

use crate::auth::{get_reg_token, get_api_key, encrypt_api_key};
use crate::curl::{curl_post, curl_get};

const UPD8_DIR_PATH: &str = "/var/local/upd8/";
const MACHINE_REGISTERED_FILE: &str = ".registered";
const MACHINE_ID_FILE: &str = "machine-id";
const KERNEL_UUID: &str = "/proc/sys/kernel/random/uuid";
const HOSTNAME_FILE_PATH: &str = "/etc/hostname";
const OS_VERSION_FILE_PATH: &str = "/etc/issue";

pub enum OtaUpdateStatus {
    Ok = 0,
    InSync = 1,
    Pulling = 2,
    Deploying = 3,
    Deployed = 4,
    Failed = 5,
    Rollback = 6,
}

#[derive(Debug)]
pub struct Machine {
    uuid: String,
    name: String,
    description: String,
    os_version: String,
}

impl Machine {
    pub fn uuid(&self) -> &str { &self.uuid }
    pub fn name(&self) -> &str { &self.name }
    pub fn description(&self) -> &str { &self.description }
    pub fn os_version(&self) -> &str { &self.os_version }
}

/// Retrieves the unique machine ID for the current device.
///
/// This function first checks if a machine ID already exists in a dedicated
/// file (`MACHINE_ID_FILE`) within the application's directory (`UPD8_DIR_PATH`).
///
/// If the file exists, the ID is read directly from it.
///
/// If the file does not exist, a new machine ID is generated by reading the
/// kernel's UUID (from `KERNEL_UUID`). This newly generated ID is then
/// written to the `MACHINE_ID_FILE` for future use, ensuring persistence
/// across reboots.
///
/// # Returns
/// - `Ok(String)` containing the unique machine ID on success.
/// - `Err(anyhow::Error)` if:
///   - The existing machine ID file cannot be read.
///   - The kernel UUID cannot be read for generating a new ID.
///   - The application directory cannot be created.
///   - The new machine ID cannot be written to the file.
fn get_machine_id() -> Result<String> {
    let upd8_dir_path = Path::new(UPD8_DIR_PATH);
    let machine_id_file_path = upd8_dir_path.join(MACHINE_ID_FILE);
    let mut machine_id;

    // Check if the machine ID file exists
    if machine_id_file_path.is_file() {
        // Read the machine ID from the file
        machine_id = fs::read_to_string(machine_id_file_path)
            .with_context(|| "Failed to read machine ID file")?;

        debug!("Found existing machine ID: {}", machine_id);
    } else {
        // Generate a new machine ID
        machine_id = fs::read_to_string(KERNEL_UUID)
            .with_context(|| "Failed to read kernel UUID")?;
        // Remove any trailing newlines
        machine_id = machine_id.trim().to_string();
        debug!("Generated machine ID: {}", machine_id);

        // Write the machine ID to the file
        fs::create_dir_all(UPD8_DIR_PATH)
            .with_context(|| "Failed to create directory for machine ID file")?;
        fs::write(machine_id_file_path, &machine_id)
            .with_context(|| "Failed to write machine ID file")?;
    }

    Ok(machine_id)
}

/// Retrieves the operating system version by reading and parsing a specific file.
///
/// This function attempts to read the content of the file specified by `OS_VERSION_FILE_PATH`.
/// It then extracts the OS version by taking the first line of the file and
/// parsing the last whitespace-separated part of that line.
///
/// # Returns
/// - `Ok(String)` containing the extracted OS version string on success.
/// - `Err(anyhow::Error)` if:
///   - The file specified by `OS_VERSION_FILE_PATH` cannot be read (e.g., file not found, permissions issue).
///   - The OS version cannot be successfully parsed from the first line of the file
///     (e.g., the file is empty, or the format of the first line is not as expected).
fn get_os_version() -> Result<String> {
    let file_content = fs::read_to_string(OS_VERSION_FILE_PATH)
        .with_context(|| "Failed to read OS version file")?;

    let os_version = file_content
        .lines()
        .next()
        .and_then(|line| {
            let version_part = line
                .split_whitespace()
                .last();

            version_part.map(|s| s.to_string())
        })
        .context(format!(
            "Failed to parse version from first line of the {} file.",
            OS_VERSION_FILE_PATH
        ))?;

    debug!("OS version: {}", os_version);
    Ok(os_version)
}

/// Initializes and creates a `Machine` struct by gathering system-specific information.
///
/// This function retrieves the machine's unique identifier (UUID), hostname, and
/// operating system version. It then combines these pieces of information to
/// construct a `Machine` instance. The hostname is read from `HOSTNAME_FILE_PATH`
/// and defaults to "unknown" if the file cannot be read.
///
/// The `Machine` struct is populated as follows:
/// - `uuid`: The unique machine ID.
/// - `name`: A combination of the hostname and UUID (e.g., "my-hostname-UUID").
/// - `description`: A combination of the hostname and UUID (e.g., "my-hostname - UUID").
/// - `os_version`: The detected operating system version.
///
/// # Returns
/// - `Ok(Machine)` on successful initialization, containing the populated machine data.
/// - `Err(anyhow::Error)` if there's a failure in obtaining the machine ID or OS version.
///   (Note: Hostname reading failures are gracefully handled by defaulting to "unknown").
pub fn init() -> Result<Machine> {
    // Get UUID
    let uuid = get_machine_id()
        .with_context(|| "Failed to get machine ID")?;

    // Get hostname
    let name = fs::read_to_string(HOSTNAME_FILE_PATH)
        .unwrap_or_else(|_| "unknown".to_string()) // Read to String, default to "unknown"
        .trim_end() // Remove trailing whitespace (including newlines), returns &str
        .to_string(); // Convert the &str back to a String

    // Get OS version
    let os_version = get_os_version()
        .with_context(|| "Failed to get OS version")?;

    // Create the machine struct
    let machine = Machine {
        uuid: uuid.clone(),
        name: format!("{}-{}", name, uuid),
        description: format!("{} - {}", name, uuid),
        os_version,
    };

    debug!("{:?}", machine);
    Ok(machine)
}

/// Requests a new access token (bearer token) from the platform's authentication API.
///
/// This function is typically used as an initial step for a machine to authenticate
/// itself and obtain a token, which is then used for subsequent authenticated API calls.
/// It sends an HTTP POST request to a dedicated token endpoint. It requires an API key
/// that is securely stored and retrieved.
///
/// # Arguments
/// * `api_url` - The base URL of your API (e.g., "https://your-api.com").
///
/// # Returns
/// - `Ok((token, ttl))` on success, where `token` is the obtained access token
///   as a `String`, and `ttl` is its time-to-live in seconds (`u64`).
/// - `Err(anyhow::Error)` if there's an issue making the API request,
///   if the API returns a non-2xx error status, or if the response
///   does not contain the expected token and TTL.
pub fn get_bearer_token(api_url: &str) -> Result<(String, u64)> {
    // Securely get the API key
    let api_key = get_api_key().with_context(|| "Failed to decrypt API key")?;

    // Prepare URL
    let url = format!("{}/machines/get-access-token", api_url);

    // Prepare HTTP Headers
    let mut http_headers = List::new();
    http_headers.append("Content-Type: application/json")?; // Crucial for sending JSON in POST body

    // Create JSON Payload for obtaining the bearer token
    let json_payload = json!({
        "api_key": String::from_utf8_lossy(api_key.expose_secret()).trim(),
    });

    // Create a redacted version for debugging request body
    let mut redacted_payload = json_payload.clone();
    if let Some(obj) = redacted_payload.as_object_mut() {
        obj.insert("api_key".to_string(), json!("[REDACTED]"));
    }
    debug!("Sending POST payload to get the bearer token: {}", redacted_payload);

    // Execute POST request using curl_post (synchronous)
    let (status_code, json_response) = curl_post(&url, http_headers, &json_payload)
        .with_context(|| "Failed to execute curl command to get the bearer token")?;
    debug!("Response from API for bearer token: {}", json_response);

    // Check HTTP status code for success (any 2xx code)
    if !(200..300).contains(&status_code) {
        return Err(anyhow!(
            "Failed to get the bearer token (status {}): {}",
            status_code,
            json_response
        ));
    }

    info!("Bearer token retrieved successfully");

    // Extract the bearer token from the response
    let access_token = json_response
        .get("access_token")
        .and_then(|v| v.as_str())
        .map(|s| s.to_string())
        .ok_or_else(|| anyhow!("Token response is missing 'access_token' field or it's not a string"))?;

    // Extract the expiry time from the response
    let expires_in = json_response
        .get("expires_in")
        .and_then(|v| v.as_u64())
        .ok_or_else(|| anyhow!("Token response is missing 'expires_in' field or it's not a u64"))?;

    Ok((access_token, expires_in))
}

/// Registers a new machine on the platform.
///
/// This function sends an HTTP POST request to the API to register a unique
/// machine with its identifying details. This is typically an initial
/// registration step before other authenticated API interactions.
/// This endpoint requires a registration token, which is securely retrieved.
///
/// # Arguments
/// * `api_url` - The base URL of your API (e.g., "https://your-api.com").
/// * `uuid` - The unique identifier of the machine (e.g., a device UUID).
/// * `name` - A human-readable name for the machine.
/// * `description` - A brief description of the machine.
///
/// # Returns
/// - `Ok(())` if the machine was successfully registered (API returned a 2xx status).
/// - `Err(anyhow::Error)` if there's an issue making the API request,
///   or if the API returns a non-2xx error status.
pub fn register(api_url: &str, uuid: &str, name: &str, description: &str) -> Result<()> {
    let upd8_dir_path = Path::new(UPD8_DIR_PATH);
    let machine_reg_file_path = upd8_dir_path.join(MACHINE_REGISTERED_FILE);

    // Check if the machine is already registered
    if machine_reg_file_path.is_file() {
        debug!("Machine already registered, skipping registration");
        return Ok(());
    }

    info!("Machine not registered, proceeding to register");

    debug!("Machine ID: {}", uuid);
    debug!("Machine name: {}", name);
    debug!("Machine description: {}", description);

    // Securely get the registration token
    let reg_token = get_reg_token().with_context(|| "Failed to decrypt registration token")?;

    // Register the machine on the platform
    let url = format!("{}/machines/register", api_url);

    // Prepare HTTP Headers
    let mut http_headers = List::new();
    http_headers.append("Content-Type: application/json")?; // Crucial for sending JSON in POST body
    http_headers.append("Accept: application/json")?; // Request JSON response back

    // Create JSON Payload for registering the machine
    let json_payload = json!({
        "reg_token": String::from_utf8_lossy(reg_token.expose_secret()).trim(),
        "uuid": uuid,
        "name": name,
        "description": description,
    });

    // Create a redacted version for debugging request body
    let mut redacted_payload = json_payload.clone();
    if let Some(obj) = redacted_payload.as_object_mut() {
        obj.insert("reg_token".to_string(), json!("[REDACTED]"));
    }
    debug!("Sending POST payload to register the machine: {}", redacted_payload);

    // Execute POST request using curl_post (synchronous)
    let (status_code, json_response) = curl_post(&url, http_headers, &json_payload)
        .with_context(|| "Failed to execute curl command to register the machine")?;

    // Create a redacted version for debugging response body
    let mut redacted_response = json_response.clone();
    if let Some(obj) = redacted_response.as_object_mut() {
        obj.insert("api_key".to_string(), json!("[REDACTED]"));
    }
    debug!("Response from API for registration: {}", redacted_response);

    // Check HTTP status code for success (any 2xx code)
    if !(200..300).contains(&status_code) {
        return Err(anyhow!(
            "Failed to register the machine (status {}): {}",
            status_code,
            json_response
        ));
    }

    info!("Machine registered successfully");

    // Extract the API key from the response
    let api_key = json_response
        .get("api_key")
        .and_then(|v| v.as_str())
        .map(|s| s.to_string())
        .ok_or_else(|| anyhow!("Registration response is missing 'api_key' field or it's not a string"))?;

    // Encrypt API key
    fs::create_dir_all(UPD8_DIR_PATH)
        .with_context(|| "Failed to create local upd8 directory")?;
    encrypt_api_key(&api_key).with_context(|| "Failed to encrypt API key")?;

    // Create the registration file to indicate that the machine is registered
    fs::write(&machine_reg_file_path, "")
        .with_context(|| "Failed to write registration file")?;
    debug!("Created registration file: {}", machine_reg_file_path.display());

    Ok(())
}

/// Sends a heartbeat signal to the platform.
///
/// This function makes an HTTP POST request to `api_url/machines/heartbeat`
/// to indicate that the device is online and operational. It authenticates
/// the request using a bearer token.
///
/// # Arguments
/// * `api_url` - The base URL of your API (e.g., "https://your-api.com").
/// * `token_manager` - A mutable reference to your `TokenManager` to get an access token.
///
/// # Returns
/// - `Ok(())` if the heartbeat was successfully sent (API returned a 2xx status).
/// - `Err(anyhow::Error)` if there's an issue getting the token, making the API request,
///   or if the API returns a non-2xx error status.
pub fn heartbeat(api_url: &str, token_manager: &mut crate::auth::TokenManager) -> Result<()> {
    // Get access token (synchronous)
    let access_token = token_manager.get_access_token()
        .context("Failed to get access token for heartbeat")?;

    // Prepare URL
    let url = format!("{}/machines/heartbeat", api_url);

    // Prepare HTTP Headers
    let mut http_headers = List::new();
    http_headers.append("Content-Type: application/json")?; // Crucial for sending JSON in POST body
    http_headers.append(&format!("Authorization: Bearer {}", access_token))?;
    http_headers.append("Accept: application/json")?; // Request JSON response back

    // Execute POST request using curl_post (synchronous)
    let (status_code, json_response) = curl_post(&url, http_headers, &json!({}))
        .with_context(|| "Failed to execute curl command to send heartbeat")?;
    debug!("Response from API for heartbeat: {}", json_response);

    // Check HTTP status code for success (any 2xx code)
    if !(200..300).contains(&status_code) {
        return Err(anyhow!(
            "Failed to send heartbeat (status {}): {}",
            status_code,
            json_response
        ));
    }

    info!("Heartbeat sent successfully");

    Ok(())
}

/// Reports the current Over-The-Air (OTA) update status to the platform.
///
/// Sends an HTTP POST request to `api_url/machines/ota/status` with the specified
/// update status in the payload. It uses a bearer token for authentication.
///
/// # Arguments
/// * `api_url` - The base URL of your API (e.g., "https://your-api.com").
/// * `status` - The current OTA update status code to report (as a `u8`).
/// * `os_version` - The OS version associated with the OTA update (e.g., "1.4.5").
/// * `token_manager` - A mutable reference to your `TokenManager` to get an access token.
///
/// # Returns
/// - `Ok(())` if the OTA status was successfully reported (API returned 2xx status).
/// - `Err(anyhow::Error)` if there's an issue getting the token, making the API request,
///   or if the API returns a non-2xx error status.
pub fn ota_status(api_url: &str, status: &u8, os_version: &str, token_manager: &mut crate::auth::TokenManager) -> Result<()> {
    // Get access token (synchronous)
    let access_token = token_manager.get_access_token()
        .context("Failed to get access token for updating OTA status")?;

    // Prepare URL
    let url = format!("{}/machines/ota/status", api_url);

    // Prepare HTTP Headers
    let mut http_headers = List::new();
    http_headers.append("Content-Type: application/json")?; // Crucial for sending JSON in POST body
    http_headers.append(&format!("Authorization: Bearer {}", access_token))?;
    http_headers.append("Accept: application/json")?; // Request JSON response back

    // Create JSON Payload for updating the OTA status
    let json_payload = json!({
        "status": status,
        "os_version": os_version,
    });
    debug!("Sending POST payload to update OTA status: {}", json_payload);

    // Execute POST request using curl_post (synchronous)
    let (status_code, json_response) = curl_post(&url, http_headers, &json_payload)
        .with_context(|| "Failed to execute curl command to update OTA status")?;
    debug!("Response from API for OTA status: {}", json_response);

    // Check HTTP status code for success (any 2xx code)
    if !(200..300).contains(&status_code) {
        return Err(anyhow!(
            "Failed to update OTA status (status {}): {}",
            status_code,
            json_response
        ));
    }

    info!("OTA status {} sent successfully", status);

    Ok(())
}

/// Reports the current operating system version to the API.
///
/// Sends an HTTP POST request to `api_url/machines/os/version` with the machine's
/// OS version in the payload. It uses a bearer token for authentication.
///
/// # Arguments
/// * `api_url` - The base URL of your API (e.g., "https://your-api.com").
/// * `os_version` - The current OS version to report (e.g., "1.4.5").
/// * `token_manager` - A mutable reference to your `TokenManager` to get an access token.
///
/// # Returns
/// - `Ok(())` if the OS version was successfully reported (API returned 2xx status).
/// - `Err(anyhow::Error)` if there's an issue getting the token, making the API request,
///   or if the API returns a non-2xx error status.
pub fn os_version(api_url: &str, os_version: &str, token_manager: &mut crate::auth::TokenManager) -> Result<()> {
    // Get access token (synchronous)
    let access_token = token_manager.get_access_token()
        .context("Failed to get access token for updating OS version")?;

    // Prepare URL
    let url = format!("{}/machines/os/version", api_url);

    // Prepare HTTP Headers
    let mut http_headers = List::new();
    http_headers.append("Content-Type: application/json")?; // Crucial for sending JSON in POST body
    http_headers.append(&format!("Authorization: Bearer {}", access_token))?;
    http_headers.append("Accept: application/json")?; // Request JSON response back

    // Create JSON Payload for updating the OS version
    let json_payload = json!({
        "version": os_version,
    });
    debug!("Sending POST payload to update OS version: {}", json_payload);

    // Execute POST request using curl_post (synchronous)
    let (status_code, json_response) = curl_post(&url, http_headers, &json_payload)
        .with_context(|| "Failed to execute curl command to update OS version")?;
    debug!("Response from API for OS version: {}", json_response);

    // Check HTTP status code for success (any 2xx code)
    if !(200..300).contains(&status_code) {
        return Err(anyhow!(
            "Failed to update OS version (status {}): {}",
            status_code,
            json_response
        ));
    }

    info!("OS version sent successfully");

    Ok(())
}

/// Retrieves the rollback trigger status from the API endpoint.
///
/// Makes an HTTP GET request to `api_url/machines/ota/rollback_trigger`
/// to determine if a rollback has been triggered according to the platform.
///
/// # Arguments
/// * `api_url` - The base URL of your API (e.g., "https://your-api.com").
/// * `token_manager` - A mutable reference to your `TokenManager` to obtain an access token.
///
/// # Returns
/// - `Ok(true)` if the API indicates a rollback has been triggered.
/// - `Ok(false)` if the API indicates no rollback has been triggered.
/// - `Err(anyhow::Error)` if there's an error making the API request,
///   parsing the response, or if the API returns an error status (non-2xx).
pub fn get_rollback_trigger_status(api_url: &str, token_manager: &mut crate::auth::TokenManager) -> Result<bool> {
    // Get access token (synchronous)
    let access_token = token_manager.get_access_token()
        .context("Failed to get access token for rollback trigger status check")?;

    // Prepare URL
    let url = format!("{}/machines/ota/rollback_trigger", api_url);

    // Prepare HTTP Headers
    let mut http_headers = List::new();
    http_headers.append(&format!("Authorization: Bearer {}", access_token))?;
    http_headers.append("Accept: application/json")?;

    // Execute GET request using curl_get (synchronous)
    let (status_code, json_response) = curl_get(&url, http_headers)
        .with_context(|| "Failed to execute curl command")?;
    debug!("Response from API rollback trigger status: {}", json_response);

    // Check HTTP status code for success
    if !(200..300).contains(&status_code) { // More robust check for 2xx status codes
        return Err(anyhow!(
            "API returned non-success status {} for rollback trigger status: {}",
            status_code,
            json_response // Include the response body for debugging API errors
        ));
    }

    // Extract the rollback trigger status from the response
    let rollback_triggered = json_response
        .get("status")
        .and_then(|v| v.as_bool())
        .ok_or_else(|| anyhow!("Rollback trigger response is missing 'status' field or it's not a boolean"))?;

    info!("Got rollback trigger status: {}", rollback_triggered);

    Ok(rollback_triggered)
}

/// Resets the rollback trigger status on the API.
///
/// This function sends an HTTP POST request to `api_url/machines/ota/rollback_trigger`
/// with a payload of `{"status": false}`. This signals to the platform that
/// any previously detected rollback trigger condition has been handled or
/// should be cleared.
///
/// # Arguments
/// * `api_url` - The base URL of your API (e.g., "https://your-api.com").
/// * `token_manager` - A mutable reference to your `TokenManager` to obtain an access token.
///
/// # Returns
/// `Ok(())` if the request was successfully sent and the API returned a 2xx status code.
/// `Err(anyhow::Error)` if there's an error getting the token, making the API request,
/// or if the API returns a non-2xx status code.
pub fn reset_rollback_trigger_status(api_url: &str, token_manager: &mut crate::auth::TokenManager) -> Result<()> {
    // Get access token (synchronous)
    let access_token = token_manager.get_access_token()
        .context("Failed to get access token for resetting rollback trigger status")?;

    // Prepare URL (assuming same endpoint as GET, but accepts POST to modify)
    let url = format!("{}/machines/ota/rollback_trigger", api_url);

    // Prepare HTTP Headers
    let mut http_headers = List::new();
    http_headers.append("Content-Type: application/json")?; // Crucial for sending JSON in POST body
    http_headers.append(&format!("Authorization: Bearer {}", access_token))?;
    http_headers.append("Accept: application/json")?; // Request JSON response back

    // Create JSON Payload for resetting the status to false
    let json_payload = json!({
        "status": false,
    });
    debug!("Sending POST payload to reset rollback trigger status: {}", json_payload);

    // Execute POST request using curl_post (synchronous)
    let (status_code, json_response) = curl_post(&url, http_headers, &json_payload)
        .with_context(|| "Failed to execute curl command to reset rollback trigger status")?;
    debug!("Response from API for reset rollback trigger status: {}", json_response);

    // Check HTTP status code for success (any 2xx code)
    if !(200..300).contains(&status_code) {
        return Err(anyhow!(
            "API failed to reset rollback trigger status (status {}): {}",
            status_code,
            json_response
        ));
    }

    info!("Successfully reset rollback trigger status");

    Ok(())
}
